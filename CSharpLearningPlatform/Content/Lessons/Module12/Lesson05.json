{
  "moduleId": 12,
  "lessonNumber": 5,
  "lessonId": "M12L05",
  "title": "DbContext & DbSet (Your Database Connection)",
  "simplifierConcept": "Imagine a library:\n\nLIBRARY BUILDING = DbContext\n• The entire library facility\n• Entry point to all resources\n• Handles check-in/check-out (SaveChanges)\n• Tracks what you borrowed (Change Tracking)\n\nBOOKSHELVES = DbSet<T>\n• Fiction shelf = DbSet<FictionBook>\n• Science shelf = DbSet<ScienceBook>\n• Each shelf (DbSet) contains books (entities) of one type\n\nDbContext responsibilities:\n• CONNECTION management\n• CHANGE TRACKING (remembers what you modified)\n• QUERY TRANSLATION (LINQ → SQL)\n• TRANSACTION management\n• CACHING (reduce database trips)\n\nDbSet<T> is a COLLECTION that:\n• Represents a table\n• Queryable with LINQ\n• Track additions/removals\n\nThink: DbContext = 'Your database session', DbSet = 'A specific table'!",
  "coderExample": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; } = string.Empty;\n    public decimal Price { get; set; }\n}\n\nclass AppDbContext : DbContext\n{\n    // DbSet = Table\n    public DbSet<Product> Products { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=app.db\");\n    }\n}\n\n// USING DbContext\nusing (var context = new AppDbContext())  // Create session\n{\n    context.Database.EnsureCreated();\n    \n    // CHANGE TRACKING\n    var product = new Product { Name = \"Laptop\", Price = 999.99m };\n    context.Products.Add(product);  // Tracked as 'Added'\n    \n    Console.WriteLine(\"State: \" + context.Entry(product).State);  // Added\n    \n    context.SaveChanges();  // Persist to database\n    Console.WriteLine(\"State: \" + context.Entry(product).State);  // Unchanged\n    \n    // QUERYING DbSet\n    var allProducts = context.Products.ToList();  // SELECT *\n    var expensive = context.Products\n        .Where(p => p.Price > 500)\n        .OrderBy(p => p.Name)\n        .ToList();  // SELECT ... WHERE ... ORDER BY\n    \n    // MODIFYING TRACKED ENTITY\n    var firstProduct = context.Products.First();\n    firstProduct.Price = 899.99m;  // EF tracks this change!\n    \n    Console.WriteLine(\"Modified state: \" + context.Entry(firstProduct).State);\n    context.SaveChanges();  // UPDATE\n    \n    // REMOVING\n    var toRemove = context.Products.Find(1);  // Find by primary key\n    if (toRemove != null)\n    {\n        context.Products.Remove(toRemove);  // Marked as Deleted\n        context.SaveChanges();  // DELETE\n    }\n    \n    // DbContext TRACKING STATUS\n    Console.WriteLine(\"Total tracked: \" + context.ChangeTracker.Entries().Count());\n}\n\n// DbContext is DISPOSED here (connection closed)\n// Always use 'using' or call Dispose()!",
  "syntaxBreakdown": [
    {
      "codeSnippet": "using (var context = new DbContext())",
      "explanation": "DbContext implements IDisposable. Use 'using' to ensure proper disposal (closes connection, releases resources). Critical!"
    },
    {
      "codeSnippet": "context.Entry(entity).State",
      "explanation": "Check entity state: Unchanged, Added, Modified, Deleted, Detached. EF tracks state automatically when you modify objects!"
    },
    {
      "codeSnippet": "DbSet operations",
      "explanation": "Add(), Remove(), Find(key), ToList(), Where(), etc. DbSet implements IQueryable<T> - full LINQ support!"
    },
    {
      "codeSnippet": "context.SaveChanges()",
      "explanation": "Persists ALL tracked changes. Batches INSERT, UPDATE, DELETE into single transaction. Call once after all changes!"
    }
  ],
  "challenge": {
    "instructions": "Demonstrate DbContext change tracking!\n\n1. Create 'Task' entity (Id, Title, IsCompleted)\n\n2. Create 'TaskDbContext' with DbSet<Task>\n\n3. Simulate change tracking states:\n   - Create new task, add to context\n   - Print state (should be 'Added')\n   - 'Save' and print state (now 'Unchanged')\n   - Modify task title\n   - Print state (now 'Modified')\n   - Mark for removal\n   - Print state (now 'Deleted')\n\n4. Show DbContext responsibilities:\n   - Print: Connection management\n   - Print: Change tracking\n   - Print: Query translation\n   - Print: Transaction management\n\n5. Emphasize 'using' statement importance!",
    "starterCode": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\n\nclass TaskItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; } = string.Empty;\n    public bool IsCompleted { get; set; }\n}\n\nclass TaskDbContext : DbContext\n{\n    public DbSet<TaskItem> Tasks { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=tasks.db\");\n    }\n}\n\nConsole.WriteLine(\"=== DbContext CHANGE TRACKING DEMO ===\");\n\n// Simulate tracking\nvar task = new TaskItem { Title = \"Learn EF Core\", IsCompleted = false };\n\nConsole.WriteLine(\"\\n[1] NEW TASK CREATED\");\nConsole.WriteLine(\"Task object created in memory\");\nConsole.WriteLine(\"State: Not tracked (Detached)\");\n\nConsole.WriteLine(\"\\n[2] ADDED TO DbContext\");\nConsole.WriteLine(\"context.Tasks.Add(task)\");\nConsole.WriteLine(\"State: Added (will INSERT on SaveChanges)\");\n\nConsole.WriteLine(\"\\n[3] SAVED TO DATABASE\");\nConsole.WriteLine(\"context.SaveChanges()\");\nConsole.WriteLine(\"State: Unchanged (in sync with database)\");\n\nConsole.WriteLine(\"\\n[4] MODIFIED\");\nConsole.WriteLine(\"task.Title = 'Learn EF Core 8'\");\nConsole.WriteLine(\"State: Modified (will UPDATE on SaveChanges)\");\n\nConsole.WriteLine(\"\\n[5] MARKED FOR DELETION\");\nConsole.WriteLine(\"context.Tasks.Remove(task)\");\nConsole.WriteLine(\"State: Deleted (will DELETE on SaveChanges)\");\n\nConsole.WriteLine(\"\\n=== DbContext RESPONSIBILITIES ===\");\nConsole.WriteLine(\"✓ Connection Management: Opens/closes database connection\");\nConsole.WriteLine(\"✓ Change Tracking: Remembers Added/Modified/Deleted\");\nConsole.WriteLine(\"✓ Query Translation: Converts LINQ to SQL\");\nConsole.WriteLine(\"✓ Transaction: SaveChanges() is atomic (all-or-nothing)\");\n\nConsole.WriteLine(\"\\n⚠️  IMPORTANT: Always use 'using' with DbContext!\");\nConsole.WriteLine(\"   using (var context = new DbContext()) { ... }\");",
    "solutionCode": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\n\nclass TaskItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; } = string.Empty;\n    public bool IsCompleted { get; set; }\n}\n\nclass TaskDbContext : DbContext\n{\n    public DbSet<TaskItem> Tasks { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlite(\"Data Source=tasks.db\");\n    }\n}\n\nConsole.WriteLine(\"=== DbContext CHANGE TRACKING DEMONSTRATION ===\");\nConsole.WriteLine(\"Showing how EF Core tracks entity states\\n\");\n\nvar task = new TaskItem { Title = \"Learn EF Core\", IsCompleted = false };\n\nConsole.WriteLine(\"[1] NEW TASK CREATED\");\nConsole.WriteLine(\"    var task = new TaskItem { Title = 'Learn EF Core' };\");\nConsole.WriteLine(\"    State: Detached (not tracked by DbContext)\");\nConsole.WriteLine(\"    Database: No changes yet\\n\");\n\nConsole.WriteLine(\"[2] ADDED TO DbContext\");\nConsole.WriteLine(\"    context.Tasks.Add(task);\");\nConsole.WriteLine(\"    State: Added\");\nConsole.WriteLine(\"    Database: Will INSERT on SaveChanges()\\n\");\n\nConsole.WriteLine(\"[3] SAVED TO DATABASE\");\nConsole.WriteLine(\"    context.SaveChanges();\");\nConsole.WriteLine(\"    State: Unchanged\");\nConsole.WriteLine(\"    Database: Row inserted, EF in sync\\n\");\n\nConsole.WriteLine(\"[4] PROPERTY MODIFIED\");\nConsole.WriteLine(\"    task.Title = 'Learn EF Core 8';\");\nConsole.WriteLine(\"    State: Modified (EF detected the change!)\");\nConsole.WriteLine(\"    Database: Will UPDATE on SaveChanges()\\n\");\n\nConsole.WriteLine(\"[5] MARKED FOR DELETION\");\nConsole.WriteLine(\"    context.Tasks.Remove(task);\");\nConsole.WriteLine(\"    State: Deleted\");\nConsole.WriteLine(\"    Database: Will DELETE on SaveChanges()\\n\");\n\nConsole.WriteLine(\"=== DbContext RESPONSIBILITIES ===\");\nConsole.WriteLine(\"✓ Connection Management:\");\nConsole.WriteLine(\"    Opens connection when needed, closes on Dispose\");\nConsole.WriteLine(\"\\n✓ Change Tracking:\");\nConsole.WriteLine(\"    Tracks: Unchanged, Added, Modified, Deleted states\");\nConsole.WriteLine(\"    Automatically detects property changes!\");\nConsole.WriteLine(\"\\n✓ Query Translation:\");\nConsole.WriteLine(\"    LINQ: context.Tasks.Where(t => t.IsCompleted)\");\nConsole.WriteLine(\"    SQL:  SELECT * FROM Tasks WHERE IsCompleted = 1\");\nConsole.WriteLine(\"\\n✓ Transaction Management:\");\nConsole.WriteLine(\"    SaveChanges() wraps in transaction (atomic!)\");\nConsole.WriteLine(\"    All changes succeed OR all fail (consistency!)\\n\");\n\nConsole.WriteLine(\"=== CRITICAL: Always Dispose! ===\");\nConsole.WriteLine(\"✓ CORRECT: using (var context = new DbContext()) { ... }\");\nConsole.WriteLine(\"✗ WRONG:   var context = new DbContext(); (never disposed!)\");\nConsole.WriteLine(\"\\nWithout dispose: Connection leaks, memory leaks, locks!\");",
    "hint": "DbContext: session with database. DbSet<T>: represents table. Change tracking: Added, Modified, Deleted, Unchanged. SaveChanges(): persists all. Always use 'using' statement!",
    "expectedOutputPatterns": ["CHANGE TRACKING", "Added", "Modified", "Deleted", "RESPONSIBILITIES", "Dispose"],
    "validationRules": [],
    "commonStickingPoints": [
      "Not disposing DbContext: Leads to connection leaks! Always use 'using' statement or manually call Dispose(). DbContext is meant for SHORT-LIVED use.",
      "Long-lived DbContext: Don't keep DbContext alive for entire app! Create per request (web) or per operation. Change tracking gets stale, memory grows.",
      "Detached entities: Entities not tracked by context = Detached. Can't SaveChanges() on detached! Must Add() or Attach() first.",
      "Multiple SaveChanges: SaveChanges() can be called multiple times, but creates multiple transactions. Batch changes, call SaveChanges() ONCE at end!"
    ]
  }
}
