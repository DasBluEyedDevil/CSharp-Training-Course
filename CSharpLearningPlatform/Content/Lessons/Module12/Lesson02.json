{
  "moduleId": 12,
  "lessonNumber": 2,
  "lessonId": "M12L02",
  "title": "What is an ORM? (The Translator Analogy)",
  "simplifierConcept": "Imagine you're American visiting France:\n\nWITHOUT TRANSLATOR:\nYou: (trying French) \\\"Je... veux... uh... café?\\\"\nBarista: \\\"Quoi?\\\"\nYou: (frustrated, pointing)\n\nWITH TRANSLATOR:\nYou: \\\"I'd like a coffee, please\\\"\nTranslator: \\\"Il aimerait un café, s'il vous plaît\\\"\nBarista: \\\"Voilà!\\\" (hands coffee)\n\nThat's an ORM (Object-Relational Mapper)!\n\nWITHOUT ORM (raw SQL):\n```csharp\nstring sql = \\\"SELECT * FROM Customers WHERE Age > 25\\\";\nvar command = connection.CreateCommand();\ncommand.CommandText = sql;\nvar reader = command.ExecuteReader();\nwhile (reader.Read())\n{\n    var customer = new Customer \n    { \n        Id = (int)reader[\\\"Id\\\"],\n        Name = (string)reader[\\\"Name\\\"]\n    };\n}\n```\nCOMPLEX! SQL strings, manual mapping, error-prone!\n\nWITH ORM (Entity Framework Core):\n```csharp\nvar customers = dbContext.Customers\n    .Where(c => c.Age > 25)\n    .ToList();\n```\nSIMPLE! C# LINQ, automatic mapping, type-safe!\n\nThink: ORM = 'Translator between C# objects and database tables. You speak C#, ORM speaks SQL!'",
  "coderExample": "// ORM CONCEPT - Entity Framework Core\n\n// 1. DEFINE YOUR CLASSES (entities)\nclass Customer\n{\n    public int Id { get; set; }  // Primary key\n    public string Name { get; set; }\n    public string Email { get; set; }\n    public int Age { get; set; }\n}\n\nclass Order\n{\n    public int Id { get; set; }\n    public int CustomerId { get; set; }  // Foreign key\n    public decimal Total { get; set; }\n    public DateTime OrderDate { get; set; }\n    \n    // Navigation property (relationship!)\n    public Customer Customer { get; set; }\n}\n\n// 2. WHAT ORM DOES BEHIND THE SCENES\n// You write:\nvar youngCustomers = dbContext.Customers\n    .Where(c => c.Age < 30)\n    .ToList();\n\n// ORM translates to SQL:\n// SELECT * FROM Customers WHERE Age < 30\n\n// You write:\nvar customer = new Customer \n{ \n    Name = \"John\", \n    Email = \"john@example.com\", \n    Age = 25 \n};\ndbContext.Customers.Add(customer);\ndbContext.SaveChanges();\n\n// ORM translates to SQL:\n// INSERT INTO Customers (Name, Email, Age) \n// VALUES ('John', 'john@example.com', 25)\n\n// You write:\nvar customer = dbContext.Customers.Find(1);\ncustomer.Email = \"newemail@example.com\";\ndbContext.SaveChanges();\n\n// ORM translates to SQL:\n// UPDATE Customers \n// SET Email = 'newemail@example.com' \n// WHERE Id = 1\n\n// BENEFITS OF ORM:\n// ✅ Type safety - compile-time errors, not runtime!\n// ✅ LINQ queries - familiar C# syntax\n// ✅ Auto-mapping - no manual reader[\"column\"] code\n// ✅ Relationships - navigate Customer.Orders easily\n// ✅ Change tracking - EF knows what changed!\n// ✅ Database agnostic - switch SQL Server to PostgreSQL easily",
  "syntaxBreakdown": [
    {
      "codeSnippet": "ORM = Object-Relational Mapper",
      "explanation": "Bridges gap between OOP (objects, classes) and relational databases (tables, rows). Translates C# to SQL automatically!"
    },
    {
      "codeSnippet": "Entity",
      "explanation": "C# class that maps to database table. Properties = table columns. Customer class → Customers table. One object = one row!"
    },
    {
      "codeSnippet": "DbContext",
      "explanation": "The 'portal' to database. Contains DbSet<T> properties for each table. Tracks changes. Generates SQL. Your main EF class!"
    },
    {
      "codeSnippet": "LINQ to SQL",
      "explanation": "Write LINQ queries on DbSet. ORM converts to SQL! .Where(), .Select(), .OrderBy() all become SELECT, WHERE, ORDER BY in SQL."
    }
  ],
  "challenge": {
    "instructions": "Understand ORM translation!\n\n1. Create a 'Book' class:\n   - int Id\n   - string Title\n   - string Author\n   - decimal Price\n   - int Year\n\n2. Create sample LINQ queries and show what SQL they would generate:\n\n   Query 1: Find all books by \\\"Orwell\\\"\n   - C# LINQ: books.Where(b => b.Author == \\\"Orwell\\\")\n   - Print equivalent SQL\n\n   Query 2: Find books over $20, sorted by price\n   - C# LINQ: books.Where(b => b.Price > 20).OrderBy(b => b.Price)\n   - Print equivalent SQL\n\n   Query 3: Get titles of books from 2020+\n   - C# LINQ: books.Where(b => b.Year >= 2020).Select(b => b.Title)\n   - Print equivalent SQL\n\n3. Show benefits of ORM:\n   - Print why type safety matters\n   - Print why LINQ is better than SQL strings\n   - Print relationship navigation benefit",
    "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Book\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Author { get; set; }\n    public decimal Price { get; set; }\n    public int Year { get; set; }\n}\n\nConsole.WriteLine(\"=== ORM TRANSLATION EXAMPLES ===\");\n\n// Query 1\nConsole.WriteLine(\"\\nQuery 1: Find books by Orwell\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Author == \\\"Orwell\\\")\");\nConsole.WriteLine(\"SQL: SELECT * FROM Books WHERE Author = 'Orwell'\");\n\n// Query 2\nConsole.WriteLine(\"\\nQuery 2: Books over $20, sorted by price\");\nConsole.WriteLine(\"C# LINQ: /* write LINQ query */\");\nConsole.WriteLine(\"SQL: /* write equivalent SQL */\");\n\n// Query 3\nConsole.WriteLine(\"\\nQuery 3: Titles of books from 2020+\");\nConsole.WriteLine(\"C# LINQ: /* write LINQ query */\");\nConsole.WriteLine(\"SQL: /* write equivalent SQL */\");\n\n// Benefits\nConsole.WriteLine(\"\\n=== WHY ORM IS BETTER ===\");\nConsole.WriteLine(\"✅ Type safety: Compiler catches 'b.Autor' typo! SQL strings = runtime error!\");\n// Add more benefits",
    "solutionCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Book\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Author { get; set; }\n    public decimal Price { get; set; }\n    public int Year { get; set; }\n}\n\nConsole.WriteLine(\"=== ORM TRANSLATION EXAMPLES ===\");\n\nConsole.WriteLine(\"\\nQuery 1: Find books by Orwell\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Author == \\\"Orwell\\\")\");\nConsole.WriteLine(\"SQL:     SELECT * FROM Books WHERE Author = 'Orwell'\");\n\nConsole.WriteLine(\"\\nQuery 2: Books over $20, sorted by price\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Price > 20).OrderBy(b => b.Price)\");\nConsole.WriteLine(\"SQL:     SELECT * FROM Books WHERE Price > 20 ORDER BY Price\");\n\nConsole.WriteLine(\"\\nQuery 3: Titles of books from 2020+\");\nConsole.WriteLine(\"C# LINQ: books.Where(b => b.Year >= 2020).Select(b => b.Title)\");\nConsole.WriteLine(\"SQL:     SELECT Title FROM Books WHERE Year >= 2020\");\n\nConsole.WriteLine(\"\\n=== WHY ORM (Entity Framework) IS BETTER ===\");\nConsole.WriteLine(\"✅ Type Safety: Compiler catches typos! 'b.Autor' = compile error. SQL string typo = runtime crash!\");\nConsole.WriteLine(\"✅ LINQ Familiarity: Same syntax as collections! No learning SQL for basic queries.\");\nConsole.WriteLine(\"✅ Refactoring: Rename 'Title' to 'BookTitle'? IDE updates all LINQ! SQL strings = manual find/replace.\");\nConsole.WriteLine(\"✅ Relationships: 'customer.Orders' just works! No manual JOINs for basic navigation.\");\nConsole.WriteLine(\"✅ Change Tracking: EF knows what changed. Just modify object and SaveChanges()!\");\nConsole.WriteLine(\"✅ Database Agnostic: Switch SQL Server → PostgreSQL? Change connection string. LINQ stays same!\");\nConsole.WriteLine(\"\\nORM = Productivity + Safety + Maintainability!\");",
    "hint": "Show LINQ query, then equivalent SQL. LINQ: .Where(condition).OrderBy(field).Select(field). SQL: SELECT field FROM table WHERE condition ORDER BY field.",
    "expectedOutputPatterns": ["ORM TRANSLATION", "C# LINQ", "SQL", "WHY", "BETTER", "Type Safety"],
    "validationRules": [],
    "commonStickingPoints": [
      "Thinking ORM is slower: Yes, hand-optimized SQL CAN be faster. But for 95% of queries, ORM is fast enough! And developer productivity matters more than microseconds.",
      "Using ORM for everything: Complex reports with 10 joins? Sometimes raw SQL is clearer! ORMs excel at CRUD operations. Use SQL for complex analytics.",
      "Not understanding SQL: ORM doesn't mean 'never learn SQL!' You should understand what SQL is generated. Use logging to see queries. Debug performance issues!",
      "Lazy loading traps: ORM can cause N+1 query problem! Loading 100 customers, then customer.Orders for each = 101 queries! Use .Include() to eager load (next lessons)."
    ]
  }
}
