{
  "moduleId": 10,
  "lessonNumber": 4,
  "lessonId": "M10L04",
  "title": "Common Async Patterns & Best Practices",
  "simplifierConcept": "You've learned async/await! But how do you use it WELL? Here are battle-tested patterns:\n\n1. ASYNC ALL THE WAY: If you call async, you should be async. Don't block with .Result or .Wait()!\n\n2. CONFIGURE AWAIT: In libraries, use 'ConfigureAwait(false)' to prevent deadlocks\n\n3. CANCELLATION: Long operations should support cancellation with CancellationToken\n\n4. ERROR HANDLING: Use try/catch around await - exceptions propagate normally!\n\n5. PARALLEL VS SEQUENTIAL:\n   - Sequential: await each task one by one\n   - Parallel: Start all, then Task.WhenAll\n\n6. CPU vs I/O:\n   - I/O bound: Use async/await (file, network, database)\n   - CPU bound: Use Task.Run for background processing\n\nThink: Async is like driving a car - you need to know not just HOW, but WHEN and WHERE to use each technique!",
  "coderExample": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Net.Http;\n\n// PATTERN 1: Error handling in async\nasync Task<string> FetchDataAsync()\n{\n    try\n    {\n        using (HttpClient client = new HttpClient())\n        {\n            return await client.GetStringAsync(\"https://api.example.com/data\");\n        }\n    }\n    catch (HttpRequestException ex)\n    {\n        Console.WriteLine(\"Network error: \" + ex.Message);\n        return \"Error occurred\";\n    }\n}\n\n// PATTERN 2: Cancellation with CancellationToken\nasync Task LongRunningTaskAsync(CancellationToken cancellationToken)\n{\n    for (int i = 0; i < 10; i++)\n    {\n        // Check if cancellation requested\n        cancellationToken.ThrowIfCancellationRequested();\n        \n        Console.WriteLine(\"Working... \" + i);\n        await Task.Delay(500, cancellationToken);\n    }\n    Console.WriteLine(\"Task completed!\");\n}\n\n// Using cancellation\nCancellationTokenSource cts = new CancellationTokenSource();\nTask task = LongRunningTaskAsync(cts.Token);\n\ncts.CancelAfter(2000);  // Cancel after 2 seconds\n\ntry\n{\n    await task;\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Task was cancelled!\");\n}\n\n// PATTERN 3: Timeout pattern\nasync Task<string> GetDataWithTimeoutAsync(int timeoutMs)\n{\n    using (CancellationTokenSource cts = new CancellationTokenSource())\n    {\n        cts.CancelAfter(timeoutMs);\n        \n        try\n        {\n            return await FetchDataAsync();  // Your async operation\n        }\n        catch (OperationCanceledException)\n        {\n            return \"Operation timed out!\";\n        }\n    }\n}\n\n// PATTERN 4: Progress reporting\nasync Task ProcessWithProgressAsync(IProgress<int> progress)\n{\n    for (int i = 0; i <= 100; i += 10)\n    {\n        await Task.Delay(200);\n        progress?.Report(i);  // Report progress\n    }\n}\n\n// Using progress\nvar progress = new Progress<int>(percent => \n{\n    Console.WriteLine(\"Progress: \" + percent + \"%\");\n});\n\nawait ProcessWithProgressAsync(progress);\n\n// PATTERN 5: Retry logic\nasync Task<string> RetryAsync(Func<Task<string>> operation, int maxRetries)\n{\n    for (int i = 0; i < maxRetries; i++)\n    {\n        try\n        {\n            return await operation();\n        }\n        catch (Exception ex)\n        {\n            if (i == maxRetries - 1) throw;  // Last attempt, rethrow\n            Console.WriteLine(\"Attempt \" + (i + 1) + \" failed, retrying...\");\n            await Task.Delay(1000 * (i + 1));  // Exponential backoff\n        }\n    }\n    throw new Exception(\"All retries failed\");\n}",
  "syntaxBreakdown": [
    {
      "codeSnippet": "CancellationToken",
      "explanation": "Pass to async methods to support cancellation. Check with 'token.ThrowIfCancellationRequested()'. Create with CancellationTokenSource. Essential for long operations!"
    },
    {
      "codeSnippet": "ConfigureAwait(false)",
      "explanation": "In library code: 'await task.ConfigureAwait(false)' prevents deadlocks. In app code (UI/ASP.NET), usually not needed. Advanced topic!"
    },
    {
      "codeSnippet": "IProgress<T>",
      "explanation": "Interface for reporting progress. Create with 'new Progress<T>(callback)'. Call 'progress.Report(value)' in async method. Useful for long operations with UI updates."
    },
    {
      "codeSnippet": "Async error handling",
      "explanation": "Use try/catch around await! Exceptions from awaited tasks propagate normally. Task.WhenAll aggregates exceptions - check task.Exception for all errors."
    }
  ],
  "challenge": {
    "instructions": "Build a robust file processor with cancellation and progress!\n\n1. Create 'async Task ProcessFilesAsync(int fileCount, CancellationToken cancellationToken, IProgress<int> progress)':\n   - Loop from 0 to fileCount\n   - For each file:\n     - Check cancellation: cancellationToken.ThrowIfCancellationRequested()\n     - Print 'Processing file [i]...'\n     - await Task.Delay(500, cancellationToken)\n     - Report progress: progress?.Report((i + 1) * 100 / fileCount)\n   - Print 'All files processed!'\n\n2. In main code:\n   - Create CancellationTokenSource\n   - Create Progress<int> that prints progress percentage\n   - Start processing 10 files\n   - Cancel after 3 seconds with cts.CancelAfter(3000)\n   - Wrap in try/catch to handle OperationCanceledException\n   - Print appropriate message if cancelled or completed",
    "starterCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nasync Task ProcessFilesAsync(int fileCount, CancellationToken cancellationToken, IProgress<int> progress)\n{\n    for (int i = 0; i < fileCount; i++)\n    {\n        // Check cancellation\n        \n        // Process file\n        Console.WriteLine(\"Processing file \" + (i + 1) + \"...\");\n        await Task.Delay(500, cancellationToken);\n        \n        // Report progress\n        int percentComplete = (i + 1) * 100 / fileCount;\n        progress?.Report(percentComplete);\n    }\n    Console.WriteLine(\"All files processed!\");\n}\n\n// Create cancellation source\nCancellationTokenSource cts = new CancellationTokenSource();\n\n// Create progress reporter\nvar progress = new Progress<int>(percent =>\n{\n    Console.WriteLine(\"Progress: \" + percent + \"%\");\n});\n\n// Start processing\nTask task = ProcessFilesAsync(10, cts.Token, progress);\n\n// Cancel after 3 seconds\ncts.CancelAfter(3000);\n\ntry\n{\n    await task;\n    Console.WriteLine(\"Processing completed successfully!\");\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Processing was cancelled!\");\n}",
    "solutionCode": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nasync Task ProcessFilesAsync(int fileCount, CancellationToken cancellationToken, IProgress<int> progress)\n{\n    for (int i = 0; i < fileCount; i++)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n        \n        Console.WriteLine(\"Processing file \" + (i + 1) + \"...\");\n        await Task.Delay(500, cancellationToken);\n        \n        int percentComplete = (i + 1) * 100 / fileCount;\n        progress?.Report(percentComplete);\n    }\n    Console.WriteLine(\"All files processed!\");\n}\n\nCancellationTokenSource cts = new CancellationTokenSource();\n\nvar progress = new Progress<int>(percent =>\n{\n    Console.WriteLine(\"Progress: \" + percent + \"%\");\n});\n\nTask task = ProcessFilesAsync(10, cts.Token, progress);\n\ncts.CancelAfter(3000);\n\ntry\n{\n    await task;\n    Console.WriteLine(\"Processing completed successfully!\");\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"\\nProcessing was cancelled!\");\n}\n\ncts.Dispose();",
    "hint": "CancellationToken: check with 'token.ThrowIfCancellationRequested()'. Progress: 'progress?.Report(value)'. Cancel: 'cts.CancelAfter(ms)'. Catch OperationCanceledException!",
    "expectedOutputPatterns": ["Processing file", "Progress", "cancelled"],
    "validationRules": [],
    "commonStickingPoints": [
      "Not checking cancellation token: If you accept CancellationToken but never check it, cancellation won't work! Call ThrowIfCancellationRequested() regularly, especially in loops.",
      "Forgetting to dispose CancellationTokenSource: CTS implements IDisposable. Always dispose: 'cts.Dispose()' or use 'using'. Leaking these can cause memory issues.",
      "Progress deadlocks in UI: Progress<T> marshals to original context (usually UI thread). If UI thread is blocked, progress updates queue up. Always await, never block!",
      "Swallowing OperationCanceledException: Don't catch and ignore this! It's expected behavior. Catch it only to clean up or log, then let it propagate (or handle gracefully)."
    ]
  }
}
