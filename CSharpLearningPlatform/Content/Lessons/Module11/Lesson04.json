{
  "moduleId": 11,
  "lessonNumber": 4,
  "lessonId": "M11L04",
  "title": "Dependency Injection (The Supply Manager)",
  "simplifierConcept": "Imagine a chef in a restaurant:\n\nBAD WAY (creating dependencies yourself):\n• Chef grows vegetables\n• Chef raises chickens\n• Chef makes plates\n• Chef builds oven\n• THEN cooks!\n\nGOOD WAY (dependencies provided):\n• Kitchen manager PROVIDES ingredients\n• Kitchen manager PROVIDES tools\n• Chef just COOKS!\n\nThat's DEPENDENCY INJECTION (DI)!\n\nDependency = Something your code needs to work (database, logger, email service)\n\nInstead of creating dependencies yourself:\n• You DECLARE what you need (interface or class type)\n• ASP.NET Core PROVIDES it (injects it)\n• You just USE it!\n\nBenefits:\n• TESTABLE - Swap real database for fake one in tests\n• FLEXIBLE - Change implementations easily\n• CLEAN - No 'new' everywhere!\n\nThink: DI = 'Don't create what you need. Ask for it, and it will be provided!'",
  "coderExample": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// STEP 1: Define interface (contract)\ninterface IProductRepository\n{\n    List<Product> GetAll();\n    Product? GetById(int id);\n    void Add(Product product);\n}\n\n// STEP 2: Implement interface\nclass ProductRepository : IProductRepository\n{\n    private readonly List<Product> _products = new()\n    {\n        new Product { Id = 1, Name = \"Laptop\", Price = 999.99m },\n        new Product { Id = 2, Name = \"Mouse\", Price = 29.99m }\n    };\n    \n    public List<Product> GetAll() => _products;\n    public Product? GetById(int id) => _products.FirstOrDefault(p => p.Id == id);\n    public void Add(Product product) => _products.Add(product);\n}\n\nclass Product\n{\n    public int Id { get; set; }\n    public string? Name { get; set; }\n    public decimal Price { get; set; }\n}\n\n// STEP 3: Register service with DI container\nbuilder.Services.AddSingleton<IProductRepository, ProductRepository>();\n\nvar app = builder.Build();\n\n// STEP 4: Inject into endpoint handlers\napp.MapGet(\"/api/products\", (IProductRepository repo) =>\n{\n    return repo.GetAll();  // DI provides the repo!\n});\n\napp.MapGet(\"/api/products/{id}\", (int id, IProductRepository repo) =>\n{\n    var product = repo.GetById(id);\n    return product is not null ? Results.Ok(product) : Results.NotFound();\n});\n\napp.MapPost(\"/api/products\", (Product product, IProductRepository repo) =>\n{\n    repo.Add(product);\n    return Results.Created($\"/api/products/{product.Id}\", product);\n});\n\napp.Run();\n\n// DI automatically provides IProductRepository to ALL endpoints!\n// Same instance shared across all requests (Singleton lifetime)",
  "syntaxBreakdown": [
    {
      "codeSnippet": "builder.Services.AddSingleton<I, T>()",
      "explanation": "Registers service with DI. ONE instance created, shared by ALL requests. Use for stateless services. <Interface, Implementation> pattern."
    },
    {
      "codeSnippet": "builder.Services.AddScoped<I, T>()",
      "explanation": "NEW instance per HTTP request. Shared within single request. Use for database contexts. Disposed after request ends."
    },
    {
      "codeSnippet": "builder.Services.AddTransient<I, T>()",
      "explanation": "NEW instance EVERY TIME requested. Use for lightweight, stateless services. Most isolated but potentially more overhead."
    },
    {
      "codeSnippet": "Injecting into handlers",
      "explanation": "Add service as parameter to handler: (IService service) => ... ASP.NET Core automatically provides it! Can mix with route/query params."
    }
  ],
  "challenge": {
    "instructions": "Build a TODO API with Dependency Injection!\n\n1. Create 'TodoItem' class (Id, Title, IsCompleted)\n\n2. Create 'ITodoRepository' interface:\n   - List<TodoItem> GetAll()\n   - TodoItem? GetById(int id)\n   - void Add(TodoItem item)\n   - void Update(int id, TodoItem item)\n   - void Delete(int id)\n\n3. Create 'TodoRepository' class implementing ITodoRepository:\n   - Use in-memory List<TodoItem>\n   - Implement all methods\n\n4. Register with DI: builder.Services.AddSingleton<ITodoRepository, TodoRepository>()\n\n5. Create endpoints that inject ITodoRepository:\n   - GET /api/todos\n   - GET /api/todos/{id}\n   - POST /api/todos\n   - PUT /api/todos/{id}\n   - DELETE /api/todos/{id}\n\n6. Print \"DI-based Todo API Ready!\"",
    "starterCode": "using Microsoft.AspNetCore.Builder;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nclass TodoItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public bool IsCompleted { get; set; }\n}\n\ninterface ITodoRepository\n{\n    // Define methods\n}\n\nclass TodoRepository : ITodoRepository\n{\n    private readonly List<TodoItem> _todos = new()\n    {\n        new TodoItem { Id = 1, Title = \"Learn DI\", IsCompleted = false }\n    };\n    private int _nextId = 2;\n    \n    // Implement interface methods\n}\n\n// Register with DI\nbuilder.Services.AddSingleton<ITodoRepository, TodoRepository>();\n\nvar app = builder.Build();\n\n// Create endpoints with DI injection\napp.MapGet(\"/api/todos\", (ITodoRepository repo) =>\n{\n    // Use repo\n});\n\n// Implement other endpoints...\n\nConsole.WriteLine(\"DI-based Todo API Ready!\");",
    "solutionCode": "using Microsoft.AspNetCore.Builder;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nclass TodoItem\n{\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public bool IsCompleted { get; set; }\n}\n\ninterface ITodoRepository\n{\n    List<TodoItem> GetAll();\n    TodoItem? GetById(int id);\n    void Add(TodoItem item);\n    void Update(int id, TodoItem item);\n    void Delete(int id);\n}\n\nclass TodoRepository : ITodoRepository\n{\n    private readonly List<TodoItem> _todos = new()\n    {\n        new TodoItem { Id = 1, Title = \"Learn DI\", IsCompleted = false }\n    };\n    private int _nextId = 2;\n    \n    public List<TodoItem> GetAll() => _todos;\n    \n    public TodoItem? GetById(int id) => _todos.FirstOrDefault(t => t.Id == id);\n    \n    public void Add(TodoItem item)\n    {\n        item.Id = _nextId++;\n        _todos.Add(item);\n    }\n    \n    public void Update(int id, TodoItem item)\n    {\n        var todo = GetById(id);\n        if (todo is not null)\n        {\n            todo.Title = item.Title;\n            todo.IsCompleted = item.IsCompleted;\n        }\n    }\n    \n    public void Delete(int id)\n    {\n        var todo = GetById(id);\n        if (todo is not null) _todos.Remove(todo);\n    }\n}\n\nbuilder.Services.AddSingleton<ITodoRepository, TodoRepository>();\n\nvar app = builder.Build();\n\napp.MapGet(\"/api/todos\", (ITodoRepository repo) => repo.GetAll());\n\napp.MapGet(\"/api/todos/{id}\", (int id, ITodoRepository repo) =>\n{\n    var todo = repo.GetById(id);\n    return todo is not null ? Results.Ok(todo) : Results.NotFound();\n});\n\napp.MapPost(\"/api/todos\", (TodoItem item, ITodoRepository repo) =>\n{\n    repo.Add(item);\n    return Results.Created($\"/api/todos/{item.Id}\", item);\n});\n\napp.MapPut(\"/api/todos/{id}\", (int id, TodoItem item, ITodoRepository repo) =>\n{\n    var existing = repo.GetById(id);\n    if (existing is null) return Results.NotFound();\n    repo.Update(id, item);\n    return Results.Ok(existing);\n});\n\napp.MapDelete(\"/api/todos/{id}\", (int id, ITodoRepository repo) =>\n{\n    var existing = repo.GetById(id);\n    if (existing is null) return Results.NotFound();\n    repo.Delete(id);\n    return Results.NoContent();\n});\n\nConsole.WriteLine(\"DI-based Todo API Ready!\");\nConsole.WriteLine(\"Using Dependency Injection for clean architecture!\");",
    "hint": "Define interface with methods. Implement in class. Register: 'builder.Services.AddSingleton<IInterface, Implementation>()'. Inject: add as parameter '(IInterface service) => ...'.",
    "expectedOutputPatterns": ["DI-based", "Todo API", "Ready"],
    "validationRules": [],
    "commonStickingPoints": [
      "Registering after builder.Build(): Must register services BEFORE 'var app = builder.Build()'! After Build(), it's too late. Services go in 'builder.Services', not 'app'.",
      "Using implementation type in endpoints: Inject INTERFACE, not implementation! Use '(IRepository repo)' not '(Repository repo)'. Interface = flexibility!",
      "Wrong lifetime choice: Singleton = one instance forever (careful with state!). Scoped = per request (good for DB contexts). Transient = every time (safe but overhead).",
      "Forgetting to register: If you inject IService but didn't register it, you get runtime error: 'Unable to resolve service'. Must register in builder.Services first!"
    ]
  }
}
